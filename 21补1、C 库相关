本文件内容翻译自参考网址

http://www.zipcon.net/~swhite/docs/computers/languages/c_programming_libraries.html




寻找 C 库



在 C 或 C++ 编程中最让人头大的问题之一，就是寻找并链接正确的库。
这类问题并没有简单的解决方案。
仅有一系列技术，加上对涉及到的想法和工具的基础理解才能得到解决的方法。



典型错误信息


can't find a library header file when compiling C file

意味着库对应的头文件并不在编译系统所期望的位置
要么是文件需要被安装，要么是编译系统需要被告知如何查找它们

在现代的系统中，这通常意味着需要安装一个 dev 包

处于效率考虑，通常系统分发包仅安装代码库
库提供了功能，但要在构建项目的时候使用库，则头文件和其它工具也一并需要，它们可能在一个另一个独立的 dev 包中
这个包通常和主库包具有类似的名称

若包并不作为分发包的一部分被安装，则它可能出现在任何一个位置
你将必须搜索它，并决定如何告诉编译系统它的位置


library function declaration doesn't match use in source code

这通常意味着被源码需要的库的版本，与已安装的库不同


symbol not found at link-time

通常需要调整 LD_LIBRARY_PATH


symbol found but not correct

库版本问题


crashes or other wrong behavior at run time

有时来自于头文件和库文件的不适配
通常通过修正路径来解决



预处理，编译和链接


构建一个 C 程序或库涉及三个阶段：预处理、编译、以及链接

1、预处理包括针对每个源文件的文本化（textual）修改——特别地，头文件被预处理器文本化（textually）引用

2、编译就是将 C 源码文件翻译为机器码的过程，并生成一个目标文件（对于每个 .c 源码文件都生成一个 .o 文件）

3、链接就是将这些目标文件（object file）与系统库拼合起来，并生成可执行文件（或库）


在 C 和 C++ 中，库通常与头文件（.h 或 .hh）相关联，后者描述了库中的公共数据结构和函数
库文件包含了实现了库功能的机器码

要使用库来构建程序，必须要在编译时引用正确的头文件，以及在链接时链接正确的库（后者可能在执行时发生）



dev 包


很多现代的基于 Unix 的分发操作系统使用一类包管理系统来安装系统软件
在很多这些系统中，很多库在安装时并不会一同安装对应的头文件，而这些头文件在使用这些库构建软件时是必须的
典型地，一个独立的，对应的包，也就是 dev 包，需要被安装，来构建这样的软件

当下，最常见的在链接时导致头文件丢失的原因就是缺少 dev 包，而其解决方法是十分简单的



静态库 vs 共享库


有两种主要的库类型，静态的以及共享的
它们的主要区别在于它们所包含的代码是如何与使用它们的程序相关联的

当程序被链接时，来自静态库的代码将被拷贝至可执行程序文件中
DNA作为共享库，仅有库文件的参考被拷贝至了可执行文件中
共享库在代码运行时（一个被称为动态链接器的程序）通过这个参考被找到
（也是这个原因所有的程序都可以“共享”使用它）

因此，链接静态库的问题发生在程序构建过程中的编译结束之后
而共享库链接问题通常发生在运行时

在类 unix 系统上，静态库文件以 .a（意为“archive”）作为结尾，共享库文件以 .so（意为“shared object”）作为结尾
在 DOS/Windows 上，共享库以 .dll（意为“dynamic linked library”）作为结尾



何处寻找头文件


在类 Unix 系统，传统的放置 C 语言系统库头文件的位置为 /usr/include/，以及其子目录
本地构建的程序通常将头文件放置在 /usr/local/include/

但头文件可以出现在任何地方
你的好伙伴将是下面的工具：

locate
和
find



何处寻找库文件


在类 Unix 系统中，传统的放置基础系统库的目录为 /lib/，大量附加的库存放于 /usr/lib/，部分存放在子目录中

除此之外，本地构建的库通常存放在 /usr/local/lib/
在现代，特殊的应用库常常存储在 /opt/ 的各种目录下

若你没有在这些地方找到你的库，你可以尝试使用 locate 和 find

若库就是没有出现在你的系统中，你就需要安装它
首先尝试判断一个来自系统分发的包是否含有该库
若失败，你将通常需要从源码构建软件
不幸的是，这个源码通常会需要更多的库



预处理器搜寻头文件的路径


C 区分两种不同的 #include 语句
那些放在尖括号之间的文件路径（#include <header.h>）
以及那些放在双引号之间的文件路径（#include "header.h"）

默认情况下，预处理器在查找尖括号包含的头文件时，会从系统库开始，而查找双引号包含的头文件时，会从当前文件所在位置查找

系统头文件的行为将被编译器命令行参数 -I 所修改，其会将其他的目录加入被编译器搜索的范围之中



链接器搜索静态库的路径


静态链接器通常包含在编译器程序的功能中，而编译器接受各种开关来控制其如何链接，以及从哪里寻找库
最重要的有

-L <目录名>
	在该开关后，编译器从该目录搜索库文件

-l<名称>
	这是 lib<名称>.a 或者 lib<名称>.so 链接行的简写

你的编译器会自动搜索存在于 /lib/ 和 /usr/lib 中的库

通常，构建系统同样会添加 /usr/local/lib/
它们通常会同时所有各类库，并测试正确版本的库是否存在
虽然这个过程常常出错

大多数编译器会默认自动链接最基础的库
在 C 中，会是 libc.a；在 C++ 中，会是 lib_stdc++.so



静态链接顺序


文件被链接的顺序会影响结果

大多数库需要来自其他库的函数
但链接器仅会包含它知道它所需要的代码
所以如果库 A 需要的函数在库 B 中，那么在链接行，库 A 必须在库 B 之前被指定

库的顺序总结起来就是：从最专有的库至最通用的库
也就是，一些高阶代码的库，比如计算某种特殊的乘法的，应该首先被提起，而若它需要标准数学库，那么标旗 -lm 应该最后被加入



动态（运行时）链接


共享库与静态库使用完全不同的机制，在不同的时间，做链接
于是乎相比静态库，所遇到的问题也不一样，发生的时间也不一样
一定程度上的理解这个过程将大有裨益

共享库的链接发生在一个程序执行的时候
它被一个系统程序——动态链接器（dynamic linker）执行
它通常被预定义为取某些地方寻找共享库，通常为 /lib 以及 /usr/lib

你可以通过设置 shell 变量 LD_LIBARAY_PATH 来将目录加入动态链接器的搜索目录，
eg.
	在 Bash shell 中：
	export LD_LIBRARY_PATH=/my/path1:/my/path2/:$LD_LIBRARY_PATH
	加入 ~/.bash_profile 中，将导致变量每次都在你登录时被设置

最后，若系统管理员要修改全局的动态链接器的搜索路径，可以修改 /etc/ld.so.conf 以及其所包含的文件，并运行 ldconfig 来实现



构建系统


Gnu configure
	通常具有允许你指定库的方法，参见
	./configure --help



剖析库


存档文件（静态 .a 库）可以使用以下命令剖析

nm

命令（可能源自于 “name” 的简写）
罗列库中所有的引用符号（symbol）（包含写入库中的符号和其他地方编写的）
被罗列的符号，具有类型 A 的即为在本库中被编写的；具有类型 U 的即为在其他库中被编写的
库中的字符串变量被列举为类型 T

共享库中的符号可以被以下命令查看

objectdump -T

对于共享库，了解什么库被引用了很重要
主要的工具为

ldd

（意为 list dynamic dependencies）
对可执行文件或者共享库运行，它会罗列引用到的共享库，以及系统任何何处寻找他们（注意这与当前环境变量 LD_LIBRARY_PATH 相关）

如要罗列库或可执行二进制文件的代码中的字符串，对它运行

strings

通常将出现库名和其他有用的提示



在很多库中间寻找符号


现在，第一手资料就是网络搜索引擎，但这一种非常不精确的为你特定的系统找符号链接的方式

一些混合 Unix 命令通常会找到其他情况无法找的符号
举例来说，在所有的 .a 库中找符号 strchr，你可以尝试：
find /usr/lib -name "*.a" -print | xrags nm -o --defined-only 2 > /dev/null | grep strchr



构建你自己的库


若你不能直接按照所需要的库包，那么你永远可以从源码构建你自己的那一份
通常的步骤是：下载库源码“tarball”（.tar.gz 或 .tgz 存档），解压——构建——安装

主要的思想在这里呈现
通常库的源码目录下的 README 或 INSTALL 文件会提供更多的信息

命令通常为以下这些

tar -xf thelibrary.tgz
cd thelibrary
./configure
make
make install

但也会有很多变数



/use/local


强烈不建议将非分发库安装在系统目录下：这是在自找麻烦

若你有权限写入 /usr/local，首选的选项就是将库安装到这个地方；这也是有责任感第书写类 Unix 软件的默认操作
若电脑是你的，或者多个用户都需要获取相同的库，则这是优先的选项


主目录

若你无法读写 /usr/local，你也可以将库安装至你的主目录下
通常这只是配置一下的事情 ./configure --prefix=your-home-dir



C++ 问题

【略过】


Fortran 问题

【略过】
