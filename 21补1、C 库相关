本文件内容翻译自参考网址

http://www.zipcon.net/~swhite/docs/computers/languages/c_programming_libraries.html




寻找 C 库



在 C 或 C++ 编程中最让人头大的问题之一，就是寻找并链接正确的库。
这类问题并没有简单的解决方案。
仅有一系列技术，加上对涉及到的想法和工具的基础理解才能得到解决的方法。



典型错误信息


can't find a library header file when compiling C file

意味着库对应的头文件并不在编译系统所期望的位置
要么是文件需要被安装，要么是编译系统需要被告知如何查找它们

在现代的系统中，这通常意味着需要安装一个 dev 包

处于效率考虑，通常系统分发包仅安装代码库
库提供了功能，但要在构建项目的时候使用库，则头文件和其它工具也一并需要，它们可能在一个另一个独立的 dev 包中
这个包通常和主库包具有类似的名称

若包并不作为分发包的一部分被安装，则它可能出现在任何一个位置
你将必须搜索它，并决定如何告诉编译系统它的位置


library function declaration doesn't match use in source code

这通常意味着被源码需要的库的版本，与已安装的库不同


symbol not found at link-time

通常需要调整 LD_LIBRARY_PATH


symbol found but not correct

库版本问题


crashes or other wrong behavior at run time

有时来自于头文件和库文件的不适配
通常通过修正路径来解决



预处理，编译和链接


构建一个 C 程序或库涉及三个阶段：预处理、编译、以及链接

1、预处理包括针对每个源文件的文本化（textual）修改——特别地，头文件被预处理器文本化（textually）引用

2、编译就是将 C 源码文件翻译为机器码的过程，并生成一个目标文件（对于每个 .c 源码文件都生成一个 .o 文件）

3、链接就是将这些目标文件（object file）与系统库拼合起来，并生成可执行文件（或库）


在 C 和 C++ 中，库通常与头文件（.h 或 .hh）相关联，后者描述了库中的公共数据结构和函数
库文件包含了实现了库功能的机器码

要使用库来构建程序，必须要在编译时引用正确的头文件，以及在链接时链接正确的库（后者可能在执行时发生）



dev 包


很多现代的基于 Unix 的分发操作系统使用一类包管理系统来安装系统软件
在很多这些系统中，很多库在安装时并不会一同安装对应的头文件，而这些头文件在使用这些库构建软件时是必须的
典型地，一个独立的，对应的包，也就是 dev 包，需要被安装，来构建这样的软件

当下，最常见的在链接时导致头文件丢失的原因就是缺少 dev 包，而其解决方法是十分简单的



静态库 vs 共享库


有两种主要的库类型，静态的以及共享的
它们的主要区别在于它们所包含的代码是如何与使用它们的程序相关联的

当程序被链接时，来自静态库的代码将被拷贝至可执行程序文件中
DNA作为共享库，仅有库文件的参考被拷贝至了可执行文件中
共享库在代码运行时（一个被称为动态链接器的程序）通过这个参考被找到
（也是这个原因所有的程序都可以“共享”使用它）

因此，链接静态库的问题发生在程序构建过程中的编译结束之后
而共享库链接问题通常发生在运行时

在类 unix 系统上，静态库文件以 .a（意为“archive”）作为结尾，共享库文件以 .so（意为“shared object”）作为结尾
在 DOS/Windows 上，共享库以 .dll（意为“dynamic linked library”）作为结尾



何处寻找头文件


在类 Unix 系统，传统的放置 C 语言系统库头文件的位置为 /usr/include/，以及其子目录
本地构建的程序通常将头文件放置在 /usr/local/include/

但头文件可以出现在任何地方
你的好伙伴将是下面的工具：

locate
和
find



何处寻找库文件


在类 Unix 系统中，传统的放置基础系统库的目录为 /lib/，大量附加的库存放于 /usr/lib/，部分存放在子目录中

除此之外，本地构建的库通常存放在 /usr/local/lib/
在现代，特殊的应用库常常存储在 /opt/ 的各种目录下

若你没有在这些地方找到你的库，你可以尝试使用 locate 和 find

若库就是没有出现在你的系统中，你就需要安装它
首先尝试判断一个来自系统分发的包是否含有该库
若失败，你将通常需要从源码构建软件
不幸的是，这个源码通常会需要更多的库



预处理器搜寻头文件的路径


C 区分两种不同的 #include 语句
那些放在尖括号之间的文件路径（#include <header.h>）
以及那些放在双引号之间的文件路径（#include "header.h"）

默认情况下，预处理器在查找尖括号包含的头文件时，会从系统库开始，而查找双引号包含的头文件时，会从当前文件所在位置查找

系统头文件的行为将被编译器命令行参数 -I 所修改，其会将其他的目录加入被编译器搜索的范围之中



链接器搜索静态库的路径


静态链接器通常包含在编译器程序的功能中，而编译器接受各种开关来控制其如何链接，以及从哪里寻找库
最重要的有

-L <目录名>
	在该开关后，编译器从该目录搜索库文件

-l<名称>
	这是 lib<名称>.a 或者 lib<名称>.so 链接行的简写

你的编译器会自动搜索存在于 /lib/ 和 /usr/lib 中的库

通常，构建系统同样会添加 /usr/local/lib/
它们通常会同时所有各类库，并测试正确版本的库是否存在
虽然这个过程常常出错

大多数编译器会默认自动链接最基础的库
在 C 中，会是 libc.a；在 C++ 中，会是 lib_stdc++.so



静态链接顺序


文件被链接的顺序会影响结果

大多数库需要来自其他库的函数
但链接器仅会包含它知道它所需要的代码
所以如果库 A 需要的函数在库 B 中，那么在链接行，库 A 必须在库 B 之前被指定

库的顺序总结起来就是：从最专有的库至最通用的库
也就是，一些高阶代码的库，比如计算某种特殊的乘法的，应该首先被提起，而若它需要标准数学库，那么标旗 -lm 应该最后被加入
