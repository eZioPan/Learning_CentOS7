正则表达式分为 基础正则表达式(basic RE) 和 扩展正则表达式(extended RE)

语系的设置对正则表达式输出的结果又很大的影响

因为不同语系对于字符的排列方式是不一样的

下面的一些符号将在不同的语系之下对应相同的字符，请注意


符号		含义
[:alnum:]	大小写英文字母 + 阿拉伯数字
[:alpha:]	大小写英文字母
[:blank:]	空格键 和 Tab 键
[:cntrl:]	键盘上的控制键，比如 CR, LF, Tab, Del 等等
[:digit:]	阿拉伯数字
[:graph:]	除了 空格键 和 Tab 键 之外的其他键
[:lower:]	小写英文字母
[:print:]	可以被打印出来的字符
[:punct:]	标点符号，比如 " ' ? ! ; : # $ 等等
[:upper:]	大写英文字母
[:space:]	会产生空白的字符，比如 空格键， Tab键， CR 等等
[:xdigit:]	十六位字符，包含 0-9 a-f A-F



grep 的进阶选项
grep [-AB] [--color=auto] <需匹配的字符串> [文件名]
-A <num> 将匹配所在位置向后（after）的 n 行也列出来
-B <num> 将匹配所在位置向前（before）的 n 行也列出来



basic RE 的语法



[字符]

中括号：待搜索项 至少出现 一次 中括号中的 某个 字符

eg.

grep 't[ae]st'

搜寻 含有 tast 或者 test 的行



[^字符]

中括号里有 ^ ：待搜索项里 不包含 括号中的 某个 字符

eg.

grep '[^g]oo'

那么不会标注 'google'，但会标注 'gooogle'，因为最后两个 o 的前面是 o ，不是 g



[字符1-字符2]

中括号里有 - ：待搜索项里包含 字符1 至 字符2 之间的任意一个字符

eg.

grep '[a-z]' 等价于 grep '[abcdefghijklmnopqrstuvwxyz]'

注意这个匹配的最终内容和系统编码相关

上述内容最好写成

gerp '[[:lower:]]'



^ 和 - 可以连用

eg.

grep '[^[:lower:]]'

表示 去除仅有小写字母的行



^字符

在方括号外使用，表示后面的字符出现在行首

eg.

grep '^[^[:upper:]]'

表示去除 以大写英文字母开头的行



字符$

表示以字符作为行结尾

eg.

grep '\.$'

将搜索已英文句号为结尾的行

由于 英文句号 . 在 RE 中有特殊的含义，所以用 反斜线 \ 来进行转义

但要注意，由于 Windows 的换行符为 <CR><FL> 而 <CR> 在 Linux 表示为 ^M
所以用 Linux 处理 Windows 文件时，一定要注意每行是以 ^M 结尾的



.

有且只有一个 任意字符

eg.

grep 'g..d'

将选出 g 在 d 前，且两者之间恰好含有两个字符的行



字符*

该字符重复 0 至 任意多次

eg.

grep 'o*'

看起来这将选择连续出现 o 这个字符的行，实际上会选择所有行
因为 * 可以匹配 0 次重复

正确写法

grep 'oo*'

首先匹配含有一个 o 的字符，紧跟其后的是 0 个或多个 o



RE 中 通配符 的写法

eg.

如果要匹配类似 g*****g 这样的内容

grep 'g*g'

这种写法是错误的，这可以匹配 g gg ggg gggg ggggg ... 这种写法

正确的写法是

grep 'g.*g'

这种写法表示：以g开头，以g结尾，且中间含有 0 个 或 多个 未知字符 的写法



字符{最少重复次数,最多重复次数}

匹配 n 至 m 次重复的字符

eg.

grep 'o\{2\}' 匹配两个 o，注意 花括号 {} 在 Bash 中有特殊含义，所以要用转义字符转义

grep '[^o]o{2}[^o]' 匹配有且仅有两个 o 连续出现

grep 'o\{2,5\}' 匹配 2 至 5 个 o 连续出现

grep 'o\{2,\}' 匹配 2 至 无穷多个 o 连续出现



sed 数据的查找、替换、删除、添加

sed [-En] '<command>' [文件1] [文件2]...

sed [-En] [[-e '<command1>'] [-e '<command2>']...] [-f command_file] [-i extension]  [文件1] [文件2]...

默认情况下，sed 从 StdOut 写出数据，也接受来自 StdIn 的数据

-E 使用 Extended RE，而不是 Basic RE 作为 command 中正则表达式的语法

-n 仅将的确被改动的行输出到 StdOut，默认会将所有行输出到 StdOut

-e 后面可以接多个 -e 参数来添加不同的 command

-f 将 command 写入一个文件中，通过这个参数调用文件来执行命令

-i 就地写入（in_place） 将修改写入原文件，若指定了 extension，则原文件的备份将使用 extension 作为扩展名


command 部分的

整个 command 部分必须用 单引号 包括起来

address1,[address2] function[arguments]

address1 address2 限定操作的行数


function 包含如下命令

a <string>	在当前操作行的下一行插入 <string>
c <string>	用 <string> 取代 address1 address2 之间行的内容
d			删除当前操作行
i <string>	在当前操作行的上一行插入 <string>
p			打印当前操作行
s/<oldString>/<newString>/g	在当前操作行中，用 <newString> 替换 <oldString>
							若不输入 <newString> 则为删除 <oldString>

eg1.

nl /etc/passwd | sed '3,5d'	在 StdOut 中删除 /etc/passwd 的 第三至第五行

eg2.

ifconfig | grep "192.168." | sed 's/.*inet //g'| sed 's/ net.*//g'

截取当前的 ip 地址



扩展正则表达式

grep -E 或 egrep 来使用扩展正则表达式

eg.

grep -v '^$' regular_expression.txt | grep -v '^#'

可以被简化为

egrep -v '^$|^#' regular_expression.txt



extended RE 的语法

<字符>+

该字符 重复了 一次或以上

eg.

egrep 'go+d'

将匹配 god good goood ...



<字符>?

该字符 没有出现或只出现了一次

eg.

egrep 'go?d'

将匹配 gd god



<RE1>|<RE2>

将匹配符合 RE1 或 RE2 的字符串

eg.

egrep '^$|^#'

将匹配 空行 或 以 # 开头的行



(<字符>)

将括号内的字符串作为群组对待

eg.

egrep 'g(la|oo)d'

将匹配 glad 或 good


群组字符也可以构成形如 ()+ ()? ()|() 的样式



printf 格式化输出

printf '<输出格式>' <待输出内容1> <待输出内容2> ...

输出格式中

可以指定以下转义字符

\a		警告声音输出
\b		退格键(backspace)
\f		清空屏幕(form feed)
\n		输出新的一行
\r		即 回车键
\t		水平制表符
\v		垂垂直制表符
\NNN	八进制数（1至3位）
\xNN	十六进制数（1至2位）
\uHHHH	Unicode 字符（4位）

可以指定以下变量

%d		十进制整数
%i		十进制整数
%f		浮点数
%c		单一字符
%s		字符串

变量可以使用使用以下修改器

- 强制左对齐（默认右对齐）
+ 强制显示正负号（默认只显示负号）
0 强制补零（默认使用空格）
非0整数 仅对 %d %i 起效，表示最小显示位数，不够的默认使用空格补位
.非0整数 仅对 %f 起效，表示最大显示小数位数，多余部分将省略

EG.

printf '%+i\n' 1 2 4
#返回
+1
+2
+4


printf '%02i %s' 1 ab 6 6
#返回01 ab06 6


注意1：printf 以 空格 作为 数据的分界
注意2：printf 不会再行尾添加 LF
注意3：printf 会将所有的数据逐次 mapping 至 格式化变量 上，直至所有的 数据都被 map 完成



awk 分栏字段处理
