rsync 快速 多功能 远程（本地） 文件拷贝 系统

语法

本地：
	rsync [OPTION...] <源数据> [目标路径]

从远程 shell 使用：
	拉取：
		rsync [OPTION...] [<用户名>@]<远程主机>:<源数据>... [目标路径]
	推送：
		rsync [OPTION...] <源数据>... [<用户>@]<远程主机>:<目标路径>

从 rsync 服务使用：
	拉取：
		rsync [OPTION...] [<用户>@]<远程主机>::<源数据>... [目标路径]
		rsync [OPTION...] rsync://[<用户>@]<远程主机>[:<端口>]/<源数据>... [目标路径]
	推送：
		rsync [OPTION...] <源数据>... [<用户>@]<远程主机>::<目标路径>
		rsync [OPTION...] <源数据> rsync://[<用户>@]<远程主机>[:<端口>]/<目标路径>


大体说明

rsync 支持 本地 与 本地 对拷、本地 与 远程 对拷，但不支持 远程 与 远程 对拷

rysnc 支持两种方式连接 远程系统：
	一种是用过连接 远程 shell（remote-shell） 作为通道（比如 ssh 或 rsh）
	或直接通过 TCP 连接至 rsync 服务

	当使用 单个冒号 : 区分 主机 和 路径时，表示使用 远程 shell
	当使用 双冒号 :: 区分 主机 和 路径时，表示使用 rsync 服务

如果仅指定 源路径 而不指定其他的内容，则罗列 源路径 下的文件，输出形式和 ls -l 类似

rsync 将 本地 视为 client，将 远程 视为 server
rsync daemon 一定是一个 server


安装

rsync 必须在 本地 及 远程 机器上安装才可以正常使用

默认情况下， rsync 通过 ssh 作为通信用的 远程 shell
这个设置可以通过选项 -e 或 环境变量 RSYNC_RSH 指定


用法

保持原有修改时间不变

	rsync -t *.c foo:src/

以 存档 的方式备份数据，并在传输之前进行压缩处理，以减少传输量

	rsync -avz foo:src/bar/ /data/tmp

若 源数据 以 / 作为结尾，则拷贝 文件夹的内容 至新目录
若 源数据 以 文件夹名 作为结尾，则在新目录下创建 文件夹，再拷贝 文件夹的内容
以下两种写法是等价的

	rsync -av /src/foo /dest
	rsync -av /src/foo/ /dest/foo

当使用 rsync daemon 时，daemon 会定义一些模块（module），
模块的配置文件 会指定 该模块可以使用的顶层目录路径 等等信息
此时， rsync 标识路径就写为

rsync -av <主机名>::<模块名>/<相对模块路径> <目标路径>

用以下命令罗列主机可使用的所有模块

rsync <主机名>::


选项

-v, --verbose
	详细模式，多个 -v 连用时，会逐步增加详细度

-q, --quiet
	静默模式，这会减少屏显输出量

--no-motd
	不显示 message-of-the-day

-I, --ignore-time
	通常来说 rsync 在文件覆盖检查时，会跳过拷贝前后 大小 和 修改时间 都一致的文件
	这个选项会关闭这个 比较 操作，让所有的文件都得到更新

--size-only
	仅以文件大小的改变作为是否开启传输的判断依据，忽略 修改时间 的影响

--modify-window
	若新旧两个文件的 修改时间 之差 在 modify-window 所定义的时间之内
	rsync 就认为这个文件的 修改时间 是一致的
	一般情况下，这个参数的大小是 0，也就是完全匹配
	但如果是与 MS Windows FAT 文件系统对拷数据，
	由于 FAT 文件系统的时间戳最小单位是 2 秒，所以 这个选项设置为 1 比较合适

-c, --checksum
	这个选项会修改 一个文件是否要被更新
	当使用这个选项时，
	若新旧文件的大小相同，rsync 会使用一个 128 位的 校验和 来确认文件 是否真的被修改过
	这个过程将消耗较多的 磁盘 IO 从而拖慢拷贝速度

	文件发送端 将在 扫描文件系统时建立 校验和列表，而文件接收端 将在 文件大小相同时 建立 文件校验和
	若两个校验和不同，则也会拷贝文件

	注意！在每个文件拷贝结束之后， rsync 会自动通过 文件校验和 来检查 文件拷贝是否完整，
	这个自动的操作和 -c 这个选项没有任何关系

	在较旧的 rsync 软件版本中（3.0.0之前），校验和使用的是 MD4，在较新的版本中（3.0.0及之后），使用的是 MD5

-a, --archive
	等价于 -rlptgoD，用于快速表明需要保留几乎所有的原始信息（除了 -H 所指定的内容）
	注意， -a 不保留 硬链接，因为寻找 多链接文件（multiply-linked files）是开销巨大的
	如果一定要保留原始的 硬链接 状态，请使用 -H 指令


--no-[选项]
	用 --no- 连上其他的选项表示 不要使用这个选项

	如果要使用 -a 但又不想使用内含的 -o，可以这么用
	-a --no-o
	注意， --no-o 一定要放置在 -a 之后

-r, --recursive
	递归拷贝整个目录，参见 --dirs (-d)

	在 rsync 3.0.0 及之后的版本中，使用 增量扫描法（incremental scan）来减小内存开销

	当使用如下参数时，rsync 需要获取全部的文件列表，于是就不会使用增量扫描法
	--delete-before --delete-after --prune-empty-dirs --delay-updates

	可以使用 --no-inc-recursive 或者 --no-i-c 来手动禁用 增量扫描法

-R, --relative
	使用相对路径。
	整个文件的绝对路径将会被传递给 rsync server，而非 只有文件名 被传递给 rsync server

	Eg.
	rsync -av /foo/bar/baz.c remote:/tmp/
	这会在 remote 上建立一个 /tmp/baz.c 文件

	rsync -avR /foo/bar/baz.c remote:/tmp/
	这会在 remote 上建立一个 /tmp/foo/bar/baz.c 文件

	上述案例中的 foo 以及 foo/bar 就被称为 隐含目录（implied directories）
	在 rsync 3.0.0 及后续版本中，即便在发送端，隐含目录 只是一个 符号链接，rsync 也会在接收端创建 真实而完整的目录
	如果你想保留 文件的 符号链接，请将 符号链接的 路径 和 符号链接 指向的 真实目录路径 都包含在内

	可以限制 传递给 rsync 的 隐含目录 的层数。
	对于在 rsync 2.6.7 及之后的版本中，只要在路径中插入一个 点斜线 ./ 就会打断将 插入点 之前的 路劲识别为 隐含目录的 过程

	Eg.
	rsync -avR /foo/./bar/baz.c remote:/tmp/
	这会在 remote 上建立一个 /tmp/bar/baz.c 文件

	对于老版本的 rsync：
		向老版本 rsync 推送过去：
			(cd /foo; rsync -avR bar/baz.c remote:/tmp/)	# 加 小括号 是为了在 sub-shell 进程中运行，而对其后操作产生影响
		从老版本 rsync 拉取进来：
			rsync -avR --rsync=path='cd /foo; rsync' remote:bar/barz.c /tmp/	# 仅针对 非 rsync daemon 的 workaround

--no-implied-dirs
	这个选项会影响 --relative 的默认行为。当它被指定时，来自 源路径的 隐含目录 的属性将不被保留。
	这意味着，若 目标地址 上有对应的 路径元素，则该 路径元素 不会被修改，若 隐含目录 没有出现在 目标路径 上，则会以默认参数创建它
	这会导致 隐含目录 在传输两侧有完全不同状态：比如 在 接受端，隐含目录 变成了一个 指向 目录的 软链接

	EG.
	若 rsync 被要求传输一个 path/foo/file 文件，而且 path/foo 被 --relative 指定为 隐含目录，
	但在 接收端 path/foo 是一个指向 文件夹 bar 的软链接，
	则默认情况下 rsync 会删除这个软链接，并创建一个新的 path/foo 文件夹

	若使用了 --no-implied-dirs，则 文件 file 将真实地存储在 path/bar 下，并随着 path/foo 的软链接 链接至 path/foo/file

	另一种保留 软链接 的方法就是使用 --keep-dirlinks 选项

	对于从 rsync 版本低于 3.0.0 的主机拉取文件，你可以使用这个选项，来将 发送端的 目录软链接 转化为 接收端的 普通目录

-b, --backup
	使用这个选项，若目标文件已存在，则在传输新文件或删除旧文件时，会备份旧文件。
	你可以使用 --backup-dir 来指定备份目录，以及使用 --suffix 指定备份用的后缀名

	若没有规定 --backup-dir，则	<1> --omit-dir-times 将被使用
								<2> 如果同时使用了 --delete（同时未使用 --delete-excluded）
									rsync 会将备份用 后缀名添加至 防删除匹配字符中，放置备份被删除

									若自定义 --delete-excluded ，则需要手动输入 备份后缀名，并使其优先级较高

--backup-dir=<目录>
	与 --backup 选项连用时，可让 rsync 接收端 将备份存放在指定的目录下

	如果该选项 使用了 相对路径，那么 备份路径 就会相对于 目标路径 而创建，此时可以使用 ../ 来表示备份
	注意，若使用 rsync daemon，由于 路径不可以高于 rsync 模块 的顶层路径，所以尽量避免在 rsync 模块的顶层路径上直接拷贝文件

--suffix=<后缀名>
	当与 --backup 连用时，自定义备份后缀名
	若没有设置 --backup-dir，则默认的备份后缀名为 波浪线 ~

-u, --update
	rsync 将跳过所有 目标目录中 文件的修改时间 新于 源文件的修改时间的 文件

	这个选项不会影响诸如 拷贝 软链接或其他类型的特殊文件
	比较 发送端 和 接收端，不同的 文件格式（file format） 也被考虑为 无视修改时间，而需要更新的对象
	就是说，如果一个路径在 发送端 和 接收端 分别为 文件 和 目录，这个文件将 无视修改时间 而被更新

	这个选项时一个 传输规则，不是一个排除规则，所以它不影响 file-lists 中的数据，也不用影响 删除动作。
	它仅限制 接收端 请求的 要被传输的 文件

--inplace
	这个选项修改了要被更新的数据将如何写入文件：
	默认情况下， rsync 在传输开始时创建一个新文件，并在传输完成之后将新文件移动至指定的目录中，
	使用该选项， rsync 会直接在原始文件数据处进行追加和修改

	这会有几个影响：
		<1> 硬链接不会打断。这意味着新数据将会被其他调用该数据块的 硬链接 所使用
			更具体的说，将不同的 源文件 拷贝至 同一个 多硬链接目标文件，会让目标文件反复被修改
		<2> 正在使用的 二进制文件 无法被更新（系统会阻止这样做，而二进制文件也会出错或崩溃）
		<3> 文件的数据 在传输过程中 将变得不完整，并且若文件传出被打断，文件的数据将保持这种不完整的状态
		<4> 文件可能无法 写入 也无法 更新。虽然 root 用户可以更新任何文件，一般用户却要 提权后 才能写入 某些数据
		<5> rsync 的 delta-transfer 算法的效率可能下降，如果先前的数据可以在 被覆盖前 移动至其他区块 反复利用的话

	注意：不可以用这个选项写入正在被其他用户使用中的数据

	这个选项对于以下的情况比较有效：
		<1> 巨大的数据量，并且数据是基于 块修改的（block-based changes）或 仅仅是 追加内容，并且 它仅限于 磁盘间传输，而没有任何 网络间传输
		<2> 对 给 写时拷贝（copy-on-write）文件系统 做镜像时，大文件中仅有少量的数据修改

	这个选项 内置 --partial（数据未传输完成也不删除文件）
	但与 --partial-dir 和 --delay-updates 冲突
	旧于 rsync 2.6.4 的版本中，该选项 还与 --compare-dust 以及 --link-dest 冲突

--append
	这个选项让 rsync 在 目标文件尾部追加新的数据，它假设了 接收端 已有的数据 和 发送端 将要发送的数据的前段 是完全一致的。
	若 接收端 的数据的大小 等于或大于 发送端，则传输就被跳过
	这个选项不影响 非文件内容 属性的更新（比如 权限 和 所有者），即使文件内容不做修改
	也不影响 非普通文件 的更新
	内置 --inplace 选项，但 不与 --sparse 选项冲突

--append-vertify
	和 --append 选项类似，但 接收端 已存在的数据 将一同加入 全文件校验和检查
	若校验失败，则 rsync 将以 普通、非追加、就地修改的模式再次传输文件

	对于 rsync 3.0.0 之前的版本， --append 和 --append-vertify 是相同的，它们都会执行 --append-vertify 的内容

-d, --dirs
	让 发送端 仅发送命令行中指定的目录本身
	与 --recursive 不同
	若 源文件 以 目录名 作为结尾，则只会在 目标路径下 创建一个 与 源目录名 相同名称的 空目录
	若 源文件 以 点号 . 斜线 / 作为结尾，则除了在 目标路径下 创建一个 相同名称的 目录，也会将 源目录下 第一层的内容 拷贝过来

	EG.
	现有目录 src{A.file,B.dir{C.file,D.dir{}}},des{}

	<1>
	rsync -dR src des/
	# des 目录的变化为 des{src{}}

	<2>
	rsync -dR src/ des/
	# des 目录的变化为 des{src{A.file,B.dir{}}}

	<3>
	rsync -dR src/./ des/
	# des 目录的变化为 des{A.file,B.dir{}}

	若不指定 --recursive 和 --dirs， rsync 仅会拷贝命令行中指定的 文件，而忽略所有的 文件夹
	若同时指定 --recursive 和 --dirs，则 rsync 会使用 --recursive

	若没有指定 --recursive，则 --dir 会内含在 --file-from 和 --list-only 选项中
	使用 --no-dirs 或 --no-d 关闭这个选项

-l, --links
	若发现了 软链接，则在 目标路径中 重建 软链接

-L, --copy-links
	若发现了 软链接，则将 它所指向的 文件 而非 软链接本身 拷贝出来。

--copy-unsafe-links
	即便 软链接 指向了 拷贝树 之外的地方，也将 指向的文件 拷贝出来。
	绝对路径软链接（absolute symlink：用绝对路径表示指向的路径）所指的文件也会被拷贝
	用 --relative 指定的 相对路径中，含有 绝对路径软链接 所指的文件也同样会被拷贝出来
	如果使用了 --copy-links，则该参数就没有效果

--safe-links
	忽略所有指向 拷贝树 之外的 软链接，也忽略所有的 绝对路径软链接

-k, --copy-dirlinks
	发送端将 链接至文件夹 的软链接 当做 真实文件夹来看待
	这仅会影响 文件夹，而不影响 其他文件

	若没有这个选项，若 发送端 用一个 指向 文件夹的 软链接 代替了 一个 文件夹，
	则接收端会 删除 任何阻碍这个 软链接 创建的 东西，包括 目录层级（如果 --force 和 --delete 都生效的话）

	参看 --keep-dirlinks 以获得 接收端 类似的帮助

-K, --keep-dirlinks
	发送端将 链接至文件夹 的软链接 当做 真实的文件夹来看待
	若没有该选项，接收端的 软链接会被删除，并被真实目录所替代

	对于接收端的类似选项 参考 --copy-dirlinks

-H, --hard-links
	这个选项让 rsync 将 保持 源数据中 指向同一个数据块的 硬链接 在 目标文件中 也指向同一个数据块
	如果不使用这个选项，目标文件 将创建不同的 数据块来记录 目标文件

	这个选项并不能保证 目标 和 源数据 具有相同的 硬链接
		<1> 如果目标具有 无关的 硬链接，那么拷贝算法就不会准确断开它们
			但是，如果一个文件的内容不同，普通的文件更新会打断这些多余的链接（除非使用了 --inplace）
		<2> 如果在 --link-dest 指定的文件夹中含有 硬链接，那么这些链接可能会由于
			--link-dest 而被链接在一起

-p, --perms
	这个选项使 接收端 将 目标的 权限设置的和 源权限相同
	（参看 --chmod 来了解 rsync 如何解读源文件的权限）

	当不使用这个选项使，使用如下的规则
		<1> 当前已存在的文件（包含被更新的文件）保持原先的权限
			仅 可执行 权限可能会被 --executability 选项改变
		<2> 新文件从源文件处读取 “普通”权限，并被目标目录的默认权限所 mask 作为最终权限
			特殊权限 基本不保留，除了 新目录 从 父目录中继承的 setgid 权限

	总而言之：给 目标文件 以 源文件的权限，使用 --perms
			给 目标文件 以 目标目录的默认权限，禁用 --perms，并添加 --chmod=ugo=rwX(不劝所有的 mask bit)

			若要给简化第二种方案的书写量，可以定义一个 popt 别名，比如将改行写入 ~/.popt 文件中

				rsync alias -Z --no-p --no-g --chmod=ugo=rwX

			这将 定义一个 -Z 选项，包含了后面所有的选项， --no-g 指定了 文件的组使用 目标目录的默认组
			将来就可以这样使用

			rsync -avZ src/ dest/

			！请保证 -a 在 -Z 之前，否则两个 --no-* 都会被重新启用

-E, --executability
	当没有使用 --perms 时，该选项将保留普通文件的 可执行/不可执行 权限
	只要 文件 包含一个 可执行 权限，该文件就被认为是可执行的
	若 已存在的目标文件 和 源文件 的 可执行权限不匹配，则按如下规则 修改 目标文件：
		<1> 若要将文件转化为 不可执行，则 rsync 会关闭所有的 x 权限
		<2> 若要将文件转化为 可执行的，则 rsync 会对所有具有 r 权限的 位置上 添加 x 权限

	若有 --perms，则该选项被忽略

-A, --acls
	这个选项让 rsync 同步 ACL 属性，这个选项内置 --perms
	目标目录必须支持 ACL 才能使这个功能正常执行。
	参看 --fake-super 来了解在不支持 ACL 的文件系统上备份和还原 ACL

-X, --xattrs
	这个选项让 rsync 同步 扩展属性（extended attribute）
	对于支持 扩展属性命名空间 的 系统，超级用户 会拷贝除 system.* 之外所有的 命名空间
								  普通用户 仅会拷贝 user.* 命名空间
								  对于以 普通用户 来备份非 user 的命名空间，参看 --fake-super 选项
	一般来说，rsync 不会拷贝特殊的 扩展属性（比如 --fake-super 会存储的部分），
	但可以使用 -XX 来拷贝所有扩展属性，注意 -XX 与 --fake-super 互斥

--chmod
	使 rsync 为传输中的文件修改权限，注意，这个修改不会修改源目录中的源文件的权限，仅可能会影响目标路径的权限
	若要指定多组不同的权限，可以使用 逗号 作为分割

	除了可以传入普通 chmod 程序的参数，
	可以在参数前加入 D 表示该参数仅对 目录 起效，加入 F 表示该参数仅对 文件 起效

	--chmod=Dg+s,ug+w,Fo-w,+X

	可以多次指定 --chmod，所有的指定都作为附加指定而产生作用

	参看 --perms
