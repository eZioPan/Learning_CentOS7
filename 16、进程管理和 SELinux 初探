什么是 进程

一段存储在存储设备中的 二进制 文件，被读取至 内存 中，并提供给 CPU 执行，内存中的数据 就是 进程

进程 含有的内容

1、PID

也就是 Process ID，是 系统 赋予每个 进程 的 标识

2、执行该程序的 使用者/使用组 的 权限

3、程序执行所需要的代码与相关的资料



Linux 创建新进程的方式 fork-and-exec


步骤1

fork：从原进程调用 fork 命令，将原进程在内存中的数据完全复制出一份来，并赋予一个不同于 原进程的 PID
	这个新进程就被称为 子进程，而原始进程就被称为 父进程


步骤2

exec：从 子进程 中执行 exec 命令，将正真需要执行的代码载入内存，并替代 原始的 子进程 的 内存内容
	此时新的代码就继承了 原始的 子进程 的 PID，并正真执行所需要的命令



bash 环境下的工作管理（job control）

注意，在 CentOS 中，默认提供 7 个 tty 用户界面以供使用，每个 tty 在登录之后都会创建不同的 bash

下面所有的 工作管理，都是在 单一 的 bash 中使用的，也就是说 工作管理 不可以跨 tty 或者 bash 使用


在命令最后加上 & 符号，可以将该行的命令置入 bash 后台 执行

eg.
tar -zpcf /tmp/etc.tar.gz /etc &
# 立刻返回
# [1] 5342
# 表示，这是一个编号为 1 的 job，它对应的 PID 是 5342
# 一会儿后，会返回
# tar: Removing leading `/' from member names
# 这是 后台运行的 tar 程序的 StdOut 和 StdErr
# 再过一会儿，会返回
# [1]+ Done		tar -zpcf /tmp/etc.tar.gz /etc &
# 表示后台 工作编号为 1 的程序 已经完成



注意，若要将置于 bash 后台中运行的命令不将 StdOut 和 StdIn 显示在前台
可以使用 数据流重导向

eg.
tar -zpcvf /etc/etc.tar.gz /etc > /tmp/log.txt 2>&1 &



Ctrl+z 将前台的命令 暂停 运行，并置入后台



jobs 观察后台工作状态

jobs [-lrs]
-l 在列表末尾显示 PID
-r 只显示 状态为 Running 的 工作
-s 只显示 状态为 Stopped 的 工作


eg.
jobs -l
[1]- 14566 Stopped		vim ~/.bashrc
[2]+ 14567 Stopped		find / -print

# 加号 + 表示 默认情况下 首个 被 fg/bg 命令选择的 工作
# 减号 - 表示 默认情况下 第二 被 fg/bg 命令选择的 工作



fg bg 将任务置入 bash 前台/后台 执行

fg [[%]jobNumber]

bg [[%]jobNumber]

eg.

fg 1
# 等价于
fg %1

bg 1
# 等价于
bg %1



kill 结束一个进程

kill [-s <SIGNAL> | -<SIGNAL>] <PID| %<jobNumber>>
kill -l

-l 列出 kill 可以使用的 SIGNAL
-s 后面接 SIGNAL 的编号，或者 SIGNAL 的名称，也可直接忽略 -s 使用 -SINGAL 的形式
可以指定 PID 或 jobNumber 来指定进程


kill 常见的 SIGNAL 有以下几个
SIGNAL	SigName		Keyboard	Comment
1		SIGHUP					普通进程：告知 Session 结束，所有输出至该 Session 的进程结束（HangUp）
								系统服务进程：重读配置文件（HangUp）
2		SIGINT		Ctrl+C		键盘中断前台进程（Interrupt）
9		SIGKILL					中断进程（Kill）
15		SIGTERM					请求结束进程（Terminate）
20		SIGTSTP		Ctrl+Z		结束输入，进程转入后台，并暂停（Type Stop）

eg.

kill -9 %1
kill -SIGTERM 1234



nohup 指定将要忽略 SIGHUP 的命令

nohup [指令与参数] [&]

当用户登出 bash 时，系统 会发出 SIGHUP 命令来要求关闭以该 bash 作为输出端口的进程
但是 nohup 会让指定的进程忽略 SIGHUP 而一直执行

若 nohup 后接的指令的 StdOut 和 StdErr 都指向当前的 bash，则会将他们都重导向至 ./nohup.out 文件中



进程的观察

ps 命令（Process Snapshot）

ps -eljH
-e 罗列系统中正在执行的所有进程
-l 长列表输出
-j 工作的格式
-H 显示进程的层级关系


eg.

ps -l
# 返回
# F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
# 0 S  1000  3280  3279  0  80   0 - 29141 wait   pts/0    00:00:00 bash
# 0 R  1000  5489  3280  0  80   0 - 37227 -      pts/0    00:00:00 ps

第一列 F 表示 Process Flags（二进制位 Mask），常见的有
	0 没有特殊的 Flag
	1 进程处于 forked 但 没有 exec 的状态
	4 进程是系统进程（具有 root 权限）
	5 同时具有 1 和 4 的 Flag

第二列 S 表示 程序状态（STAT），常见的有
	D 不可被打断的休眠状态（程序正在 IO）
	R 正在执行，或（在执行队列中）可被执行
	S 可被打断的休眠状态（等待某个事件被完成）
	T 停止状态，被工作控制信号暂停，或正在被追踪（debug）
	Z 僵尸进程，子进程结束，但父进程未回收子进程的返回信息，致使子进程有一部分未能移出内存

第三至五列 UID/PID/PPID 表示 该进程的 使用者 ID 、 进程 ID 、 父进程 ID

第六列 C 表示 CPU 使用率，单位 为 百分之一

第七至八列 PRI/NI 表示 Priority/Nice 即程序优先级

第九列 ADDR 表示 普通进程的进程栈的段号，内核进程的预处理数据地址

第十列 SZ 表示 进程占用的内存量

第十一列 WCHAN 表示 睡眠中或等待中的进程正在等待的事件

第十二列 TTY 表示 控制该进程的 终端机设备

第十三列 TIME 表示 该进程占用的 CPU 时间

第十四列 CMD 表示 出发该进程的指令是什么



top 连续观察系统状态

详细内容见文件 16补、top 命令的详细用法



pstree 进程树状图

pstree 返回值解释

init-+-getty
     |-getty
     |-getty
     --getty

当一个 父进程 下 有同名的 子程序 的时候，会被缩写成

init---4*[getty]


init-+-{getty}
     |-{getty}
     |-{getty}
     --{getty}

当一个 进程 下 有同名的 子进程 的时候，会被缩写成

init---4*[{getty}]
